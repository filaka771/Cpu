* Ded CPU
CPU has three main parts, that should be three separate binaries:
- assembler
- disassembler
- executor (CPU)

** How to write assembler?
Assembler takes text file as an input and generates a binary file which can later be executed on CPU.

#+begin_src sh
echo "out 5" > file.s
./bin/asm file.s file.exe
./bin/cpu file.exe # prints "5"
#+end_src

I recommend you to support such instructions:
#+begin_src asm
    ;; In/Out
    inp ; Input (read) a number from stdin
    out ; Output (print) a number to stdout
    
    ;; Arithmetic instructions
    mov ; Move (copy) data from thing to thing
    add ; Add one thing to other thing
    sub ; Substitute (minus) one thing from another
    mul ; Multiply one thing by another
    div ; Divide one thing by another
    sqr ; Square root

    ;; Branch instructions
    bne ; Branch on Not Equal
    beq ; Branch on Equal
    bgt ; Branch if Greater Than
    blt ; Branch if Less Than
    bge ; Branch if Greater or Equal
    ble ; Branch if Less or Equal
    baw ; Branch AnyWay

    ;; Stack ops
    str ; Store a thing to stack (push)
    ldr ; Read a thing from stack (pop)

    ;; Functions 
    bfn ; Call fuNction
    ret ; Return from a function

    ;; Control execution
    hlt ; Stop execution of a program
#+end_src

Names of this instruction are of my own creation, here a table that matches them with common names
used in x86-64 and arm64 architectures:

|  # | My suggested name | x86-64 | aarch64             | Common in Ded CPUs unaligned name |
|----+-------------------+--------+---------------------+-----------------------------------|
|  0 | inp               | --     | --                  | in                                |
|  1 | out               | --     | --                  | out                               |
|  2 | mov               | mov    | mov                 | mov                               |
|  3 | add               | add    | add                 | add                               |
|  4 | sub               | sub    | sub                 | sub                               |
|  5 | mul               | imul   | mul                 | mul                               |
|  6 | div               | idiv   | sdiv                | div                               |
|  7 | sqr               | --     | --                  | sqrt                              |
|  8 | bne               | jne    | bne                 | jne                               |
|  9 | beq               | je     | be                  | je                                |
| 10 | bgt               | jg     | bgt                 | jg                                |
| 11 | blt               | jl     | blt                 | jl                                |
| 12 | bge               | jge    | bge                 | jge                               |
| 13 | ble               | jle    | ble                 | jle                               |
| 14 | str               | push   | str __, [sp, #-16]! | push                              |
| 15 | ldr               | pop    | ldr __, [sp], #16   | pop                               |
| 16 | cfn               | call   | bl                  | call                              |
| 17 | ret               | ret    | ret                 | ret                               |
| 18 | htl               | htl    | hlt                 | hlt                               |


These instructions should have a binary representation that is easy to produce and execute, I recommend:
| Byte |             0--3 | 4--7 | 8--11 | 12--15 |
|------+------------------+------+-------+--------|
| Name | Opcode + Op kind | Imm0 |  Imm1 |   Imm2 |

So, yeah, that's 16 bytes per instructions and that's a lot, but it will make everything a lot
simpler.

Opcode + Op kind can look like this:
| Bits |   0--4 |    5 |    6 |    7 |    8 |    9 |   10 |     11-31 |
|------+--------+------+------+------+------+------+------+-----------|
| Name | Opcode | Mem0 | Reg0 | Mem1 | Reg1 | Mem2 | Reg2 | Unused :) |


Example format:
#+NAME: asm-example
#+begin_src asm
    inp x0         ; opcode = 0; mem0 = 0; reg0 = 1; imm0 = 0 (x0); imm1--imm2 are unused
    out x0         ; opcode = 1; mem0 = 0; reg0 = 1; imm0 = 0 (x0); imm1--imm2 are unused
    
    :00
    mov x0 x1      ; opcode = 2; mem0 = 0; reg0 = 1; mem1 = 0; reg1 = 1; imm0 = 0 (x0); imm1 = 1 (x1); imm2 is unused
    add x0 x1 x2   ; opcode = 3; mem0 = 0; reg0 = 1; mem1 = 0; reg1 = 1; mem2 = 0; reg2 = 1; imm0 = 0 (x0); imm1 = 1 (x1); imm2 = 2 (x2)
    sub x0 x1 5    ; opcode = 4; mem0 = 0; reg0 = 1; mem1 = 0; reg1 = 1; mem2 = 0; reg2 = 0; imm0 = 0 (x0); imm1 = 1 (x1); imm2 = 5
    mul x0 x1 *x2  ; opcode = 5; mem0 = 0; reg0 = 1; mem1 = 0; reg1 = 1; mem2 = 1; reg2 = 1; imm0 = 0 (x0); imm1 = 1 (x1); imm2 = 5
    div x0 x1 *5   ; opcode = 6; mem0 = 0; reg0 = 1; mem1 = 0; reg1 = 1; mem2 = 1; reg2 = 0; imm0 = 0 (x0); imm1 = 1 (x1); imm2 = 5
    sqr x0 *x1 x2  ; opcode = 7; mem0 = 0; reg0 = 1; mem1 = 1; reg1 = 1; mem2 = 0; reg2 = 1; imm0 = 0 (x0); imm1 = 1 (x1); imm2 = 5

    :01
    bne x0 x1 :01  ; opcode = 8; mem0 = 0; reg0 = 1; mem1 = 1; reg1 = 1; mem2 = 0; reg2 = 1; imm0 = 0 (x0); imm1 = 1 (x1); imm2 = <address, in this case 128 = 8 (it's 8-th instruction) * 16 bytes (size of one instruction)>
    beq x1 *x0 :00 ; jump to label :00 if x1 == *x0, encoded similarly
    ;; all other branch instructions are encoded in the same way...

    :02
    str x0 ; encoded like inp/out
    ldr x1 ; encoded like inp/out/str

    cfn :02 ; imm0 stores address, everything else is encoded as in inp/out/str/ldr
    ret ; all imm-s and bits except opcode are unused 

    hlt ; all imm-s and bits except opcode are unused 
#+end_src

This format is easy to parse, arguments and function names are separated by space, labels always
start with ":", registers always start with "x", numbers always start with "0-9" and "*" that
immediately preceeds register name or number means dereferencing.

This makes it easy to make a function that parses one separate operand.

Simplest way to get addresses for all labels is two assemble twice. Every time we meet a label
we add it to a table. By the time we assemble instruction that uses that lable we put it's address
if it's is already in the table (defined before currently assembled instruction) or we put zero
as a placeholder. Than we run assembler again without flushing the table, which should put all
addresses in the correct places.

** How to write disassembler?
Diassembler takes binary file generated by assembler and dumps it in readable format like this:
#+begin_src asm
0x00    inp x0
0x10    out x0
0x20    mov x0 x1
0x30    add x0 x1 x2
0x40    sub x0 x1 5
0x50    mul x0 x1 *x2
0x60    div x0 x1 *5
0x70    sqr x0 *x1 x2
0x80    bne x0 x1 0x80
0x90    beq x1 *x0 0x20
0xA0    str x0
0xB0    ldr x1
0xC0    cfn 0xA0
0xD0    ret
0xE0    hlt
#+end_src

This should be the output of assembled file that I showed as example in [[asm-example][previous section]].

** How to write CPU?
Now you should take your binary file, read it into an array of structures, each of them represents
an instruction, ideally this should be a simple open() in binary mode and read.

Than you iterate through list of instructions and execute them one by one. You should keep track of
currently executed position in the binary and call it "IP" (instruction pointer).

Use 32 registers, make an array to store values. Only use signed 32-bit integers for all computations.

Use a larger array to model memory. And you can also use a separate stack to model stack (which is
used by push/pop, call/ret)

The heart of your CPU is a big switch case which know how to execute all instructions, this switch
case can be later automatically generated from a file with macros which describe your instructions,
but for now it's simpler to write it by hand.

** How to approach writing CPU?
*** TODO Write a few example programs to get the hang of it
**** TODO Iterative factorial
**** TODO Recursive factorial
**** TODO Recursive fibonacci
**** TODO Quadratic in integers
**** TODO Drawing circle using ASCII symbols (at the end)
*** TODO Write basic structs to store instructions
*** TODO Write disassembler, which iterates over an array of such structs and prints them
Disassembler will also be useful for testing your assembler, which you will write next
*** TODO Write assembler
**** TODO Start with writing function that parses one single operand
**** TODO Write main loop, that reads start of the line every time
Don't support comment or empty lines at the start, do all the parsing using simple scanf calls and
store info to static buffers, don't use dynamic allocations or arbitrary sizes, they will complicate
everything
**** TODO Write binary file writer and just dump your data as is (one extra thing you can do is adding version and magick at the start of your binary, but that's it)
**** TODO Test it using disassembler
*** TODO Write CPU
**** TODO Write structure with all main data structures: regs, memory, stack
**** TODO Write function which executes instruction, make convenience functions like ~read_from_operand~ to access data encoded by operands in instructions
**** TODO Write main loop that calls it on every instruction
**** TODO Write binary file reader

